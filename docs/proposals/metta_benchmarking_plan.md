# MeTTaTron Optimization Benchmarking Plan

**Date**: 2025-01-10
**Related**: `metta_pathmap_optimization_proposal.md`, `metta_implementation_roadmap.md`

## Table of Contents

1. [Benchmark Suite Structure](#suite-structure)
2. [Per-Optimization Benchmarks](#per-optimization)
3. [Test Data Generation](#test-data)
4. [Measurement Methodology](#methodology)
5. [Success Criteria](#success-criteria)
6. [Continuous Integration](#ci)

---

<a name="suite-structure"></a>
## Benchmark Suite Structure

### Using Criterion.rs

**Add to Cargo.toml**:
```toml
[dev-dependencies]
criterion = { version = "0.5", features = ["html_reports"] }

[[bench]]
name = "metta_optimizations"
harness = false
```

**Benchmark File Structure**:
```
benches/
├── metta_optimizations.rs         (Main benchmark suite)
├── helpers/
│   ├── test_data.rs               (Data generation)
│   └── setup.rs                   (Environment setup)
└── results/                        (Generated by Criterion)
    ├── rule_matching/
    ├── fact_operations/
    └── completion/
```

---

<a name="per-optimization"></a>
## Per-Optimization Benchmarks

### Optimization #1: Rule Index Benchmark

**File**: `benches/metta_optimizations.rs`

```rust
use criterion::{black_box, criterion_group, criterion_main, Criterion, BenchmarkId};

fn bench_rule_matching(c: &mut Criterion) {
    let mut group = c.benchmark_group("rule_matching");

    // Test with different rule set sizes
    for size in [100, 500, 1000, 5000].iter() {
        // Before optimization: Full iteration
        group.bench_with_input(
            BenchmarkId::new("before_O(2n)", size),
            size,
            |b, &size| {
                let env = setup_env_with_rules(*size);
                let test_expr = MettaValue::SExpr(vec![
                    MettaValue::Atom("fibonacci".to_string()),
                    MettaValue::Atom("5".to_string()),
                ]);

                b.iter(|| {
                    try_match_all_rules_iterative_old(
                        black_box(&test_expr),
                        black_box(&env)
                    )
                });
            },
        );

        // After optimization: Indexed lookup
        group.bench_with_input(
            BenchmarkId::new("after_O(k+m)", size),
            size,
            |b, &size| {
                let env = setup_env_with_indexed_rules(*size);
                let test_expr = MettaValue::SExpr(vec![
                    MettaValue::Atom("fibonacci".to_string()),
                    MettaValue::Atom("5".to_string()),
                ]);

                b.iter(|| {
                    try_match_all_rules_iterative_optimized(
                        black_box(&test_expr),
                        black_box(&env)
                    )
                });
            },
        );
    }

    group.finish();
}

criterion_group!(benches, bench_rule_matching);
criterion_main!(benches);
```

**Expected Results**:
```
rule_matching/before_O(2n)/100    time:   [50.0 µs ... 55.0 µs]
rule_matching/after_O(k+m)/100    time:   [2.0 µs ... 3.0 µs]   (20-25x faster)

rule_matching/before_O(2n)/1000   time:   [500 µs ... 550 µs]
rule_matching/after_O(k+m)/1000   time:   [10 µs ... 15 µs]    (35-50x faster)
```

---

### Optimization #2: has_sexpr_fact Benchmark

```rust
fn bench_has_sexpr_fact(c: &mut Criterion) {
    let mut group = c.benchmark_group("has_sexpr_fact");

    for fact_count in [1000, 5000, 10000].iter() {
        // Before: Full scan
        group.bench_with_input(
            BenchmarkId::new("before_O(n)", fact_count),
            fact_count,
            |b, &count| {
                let env = setup_env_with_facts(*count);
                let test_fact = MettaValue::SExpr(vec![
                    MettaValue::Atom(":".to_string()),
                    MettaValue::Atom("foo".to_string()),
                    MettaValue::Atom("Int".to_string()),
                ]);

                b.iter(|| {
                    env.has_sexpr_fact_old(black_box(&test_fact))
                });
            },
        );

        // After: Prefix navigation
        group.bench_with_input(
            BenchmarkId::new("after_O(k+m)", fact_count),
            fact_count,
            |b, &count| {
                let env = setup_env_with_facts(*count);
                let test_fact = MettaValue::SExpr(vec![
                    MettaValue::Atom(":".to_string()),
                    MettaValue::Atom("foo".to_string()),
                    MettaValue::Atom("Int".to_string()),
                ]);

                b.iter(|| {
                    env.has_sexpr_fact_optimized(black_box(&test_fact))
                });
            },
        );
    }

    group.finish();
}
```

**Expected Results**:
```
has_sexpr_fact/before_O(n)/1000    time:   [100 µs ... 120 µs]
has_sexpr_fact/after_O(k+m)/1000   time:   [5 µs ... 8 µs]     (15-20x faster)

has_sexpr_fact/before_O(n)/10000   time:   [1000 µs ... 1200 µs]
has_sexpr_fact/after_O(k+m)/10000  time:   [10 µs ... 15 µs]   (70-100x faster)
```

---

### Optimization #3: has_fact Correctness Test

**Note**: This is a **correctness fix**, not performance optimization

```rust
#[test]
fn test_has_fact_correctness() {
    let mut env = Environment::new();

    // Add some facts
    env.add_fact(MettaValue::Atom("foo".to_string()));
    env.add_fact(MettaValue::Atom("bar".to_string()));

    // Before fix: WRONG results
    assert!(env.has_fact_old("foo"));        // True (correct by luck)
    assert!(env.has_fact_old("baz"));        // True (WRONG!)

    // After fix: CORRECT results
    assert!(env.has_fact_optimized("foo"));  // True ✓
    assert!(!env.has_fact_optimized("baz")); // False ✓
}
```

---

### Optimization #4: Completion Cache Benchmark

```rust
fn bench_completion_cache(c: &mut Criterion) {
    let mut group = c.benchmark_group("completion");

    for completion_count in [100, 500, 1000].iter() {
        // Before: Rebuild + filter + sort per keystroke
        group.bench_with_input(
            BenchmarkId::new("before_per_keystroke", completion_count),
            completion_count,
            |b, &count| {
                let helper = setup_helper_with_completions(*count);

                b.iter(|| {
                    helper.complete_old(
                        black_box("(fib"),
                        black_box(4),
                        black_box(&ctx)
                    )
                });
            },
        );

        // After: Binary search on cached data
        group.bench_with_input(
            BenchmarkId::new("after_cached", completion_count),
            completion_count,
            |b, &count| {
                let helper = setup_helper_with_cached_completions(*count);

                b.iter(|| {
                    helper.complete_optimized(
                        black_box("(fib"),
                        black_box(4),
                        black_box(&ctx)
                    )
                });
            },
        );
    }

    group.finish();
}
```

**Expected Results**:
```
completion/before_per_keystroke/500   time:   [250 µs ... 300 µs]
completion/after_cached/500           time:   [5 µs ... 8 µs]      (40-60x faster)

completion/before_per_keystroke/1000  time:   [500 µs ... 600 µs]
completion/after_cached/1000          time:   [8 µs ... 12 µs]     (50-75x faster)
```

---

### Optimization #5: FuzzyCache Benchmark

```rust
fn bench_fuzzy_completion(c: &mut Criterion) {
    let mut group = c.benchmark_group("fuzzy_completion");

    // Test typo tolerance performance
    group.bench_function("exact_match", |b| {
        let helper = setup_helper_with_fuzzy_cache();
        b.iter(|| {
            helper.complete_fuzzy(
                black_box("(eval"),
                black_box(5)
            )
        });
    });

    group.bench_function("typo_1_edit", |b| {
        let helper = setup_helper_with_fuzzy_cache();
        b.iter(|| {
            helper.complete_fuzzy(
                black_box("(evl"),  // Typo!
                black_box(4)
            )
        });
    });

    group.bench_function("typo_2_edits", |b| {
        let helper = setup_helper_with_fuzzy_cache();
        b.iter(|| {
            helper.complete_fuzzy(
                black_box("(evll"),  // 2 typos
                black_box(5)
            )
        });
    });

    group.finish();
}
```

**Expected Results**:
```
fuzzy_completion/exact_match     time:   [3 µs ... 5 µs]
fuzzy_completion/typo_1_edit     time:   [8 µs ... 12 µs]    (Still very fast!)
fuzzy_completion/typo_2_edits    time:   [15 µs ... 25 µs]   (More fuzzy = slower)
```

---

<a name="test-data"></a>
## Test Data Generation

### Helper Functions

**File**: `benches/helpers/test_data.rs`

```rust
use metta_compiler::backend::Environment;
use metta_compiler::ir::MettaValue;

/// Generate environment with N rules
pub fn setup_env_with_rules(count: usize) -> Environment {
    let mut env = Environment::new();

    // Generate diverse rules
    for i in 0..count {
        let rule_name = if i % 10 == 0 {
            "fibonacci".to_string()
        } else if i % 10 == 1 {
            "eval".to_string()
        } else {
            format!("rule_{}", i)
        };

        let rule = Rule {
            lhs: MettaValue::SExpr(vec![
                MettaValue::Atom(rule_name),
                MettaValue::Atom(format!("$arg{}", i)),
            ]),
            rhs: MettaValue::Atom("...".to_string()),
        };

        env.add_rule(rule);
    }

    env
}

/// Generate environment with N facts (diverse heads)
pub fn setup_env_with_facts(count: usize) -> Environment {
    let mut env = Environment::new();

    for i in 0..count {
        // 10% type assertions, 20% rules, 70% other facts
        let head = if i % 10 == 0 {
            ":"
        } else if i % 5 == 0 {
            "rule"
        } else {
            &format!("fact_{}", i % 100)
        };

        let fact = MettaValue::SExpr(vec![
            MettaValue::Atom(head.to_string()),
            MettaValue::Atom(format!("data_{}", i)),
        ]);

        env.add_fact(fact);
    }

    env
}

/// Generate completion helper with N completions
pub fn setup_helper_with_completions(count: usize) -> MettaHelper {
    let mut helper = MettaHelper::new();

    for i in 0..count {
        let func_name = match i % 5 {
            0 => format!("fibonacci{}", i),
            1 => format!("eval{}", i),
            2 => format!("process{}", i),
            3 => format!("match{}", i),
            _ => format!("func_{}", i),
        };

        helper.defined_functions.push(func_name);
    }

    helper.update_from_environment(&Environment::new());
    helper
}
```

---

<a name="methodology"></a>
## Measurement Methodology

### Benchmark Configuration

**Criterion Settings**:
```rust
fn criterion_config() -> Criterion {
    Criterion::default()
        .sample_size(100)                // 100 samples per benchmark
        .measurement_time(Duration::from_secs(5))  // 5 seconds per measurement
        .warm_up_time(Duration::from_secs(2))      // 2 seconds warmup
        .with_plots()                             // Generate HTML plots
}

criterion_group! {
    name = benches;
    config = criterion_config();
    targets = bench_rule_matching, bench_has_sexpr_fact, // ...
}
```

### Statistical Significance

**Criterion Reports**:
- **Mean**: Average execution time
- **Median**: Middle value (less affected by outliers)
- **Std Dev**: Variance in measurements
- **Confidence Interval**: 95% confidence bounds

**Example Output**:
```
rule_matching/before_O(2n)/1000
  time:   [498.23 µs 505.12 µs 512.45 µs]
  change: [-2.1234% +0.5432% +3.2156%] (p = 0.23 > 0.05)

rule_matching/after_O(k+m)/1000
  time:   [9.823 µs 10.125 µs 10.445 µs]
  change: [-98.012% -97.998% -97.984%] (p = 0.00 < 0.05)
```

**Interpretation**:
- Before: ~505µs (no significant change)
- After: ~10µs (97.998% faster, highly significant!)
- **Speedup**: 505µs / 10µs = **50.5x faster**

---

<a name="success-criteria"></a>
## Success Criteria

### Per-Optimization Targets

| Optimization | Target Speedup | Acceptable Range | Measurement |
|-------------|----------------|------------------|-------------|
| #1: Rule Index | 20-50x | 15x minimum | Mean time comparison |
| #2: has_sexpr_fact | 10-90x | 8x minimum | Mean time comparison |
| #3: has_fact | N/A (correctness) | All tests pass | Test assertions |
| #4: Completion Cache | 50-100x | 30x minimum | Mean time comparison |
| #5: FuzzyCache | 24-50x | 15x minimum | Mean time comparison |
| #6: match_space | 20-97x | 10x minimum | Mean time comparison |
| #7: Type Index | 100-1000x | 50x minimum | Mean time comparison |

### Validation Process

For each optimization:
1. **Run benchmarks**: `cargo bench --bench metta_optimizations`
2. **Check speedup**: Compare before/after means
3. **Verify significance**: p-value < 0.05
4. **Validate range**: Speedup within acceptable range
5. **Review plots**: HTML reports in `target/criterion/`

**Pass Criteria**:
- ✅ All speedups meet minimum targets
- ✅ All measurements statistically significant (p < 0.05)
- ✅ No performance regressions in other operations
- ✅ All correctness tests pass

---

<a name="ci"></a>
## Continuous Integration

### Benchmark Workflow

**GitHub Actions** (`.github/workflows/benchmarks.yml`):
```yaml
name: Performance Benchmarks

on:
  pull_request:
    branches: [main]
  push:
    branches: [main]

jobs:
  benchmark:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3

      - name: Install Rust
        uses: actions-rs/toolchain@v1
        with:
          toolchain: stable

      - name: Run benchmarks
        run: cargo bench --bench metta_optimizations

      - name: Upload results
        uses: actions/upload-artifact@v3
        with:
          name: criterion-results
          path: target/criterion/

      - name: Compare with baseline
        run: |
          # Compare current results with main branch
          # Fail if performance regressed > 10%
```

### Performance Regression Detection

**Compare with Baseline**:
```bash
# Save baseline (main branch)
git checkout main
cargo bench --bench metta_optimizations -- --save-baseline main

# Test optimization branch
git checkout feature/optimizations
cargo bench --bench metta_optimizations -- --baseline main

# Criterion will show percentage changes
```

**Example Output**:
```
rule_matching/after_O(k+m)/1000
  time:   [10.2 µs 10.5 µs 10.8 µs]
  change: [+2.0% +5.0% +8.0%] (p = 0.01)  ⚠️ Slight regression
  thrpt:  [92.6 Kelem/s 95.2 Kelem/s 98.0 Kelem/s]
```

---

## Benchmark Execution Plan

### Initial Baseline

**Before any optimization**:
```bash
git checkout main
cargo bench --bench metta_optimizations -- --save-baseline before_optimizations
```

### Per-Phase Benchmarking

**Phase 1 (Quick Wins)**:
```bash
# After Optimization #3, #4, #2
cargo bench --bench metta_optimizations -- --baseline before_optimizations
# Save new baseline
cargo bench --bench metta_optimizations -- --save-baseline phase1_complete
```

**Phase 2 (High-Impact)**:
```bash
# After Optimization #1, #7
cargo bench --bench metta_optimizations -- --baseline phase1_complete
cargo bench --bench metta_optimizations -- --save-baseline phase2_complete
```

**Phase 3 (Advanced)**:
```bash
# After Optimization #5, #6
cargo bench --bench metta_optimizations -- --baseline phase2_complete
cargo bench --bench metta_optimizations -- --save-baseline phase3_complete
```

### Final Validation

**Compare complete implementation with original**:
```bash
cargo bench --bench metta_optimizations -- --baseline before_optimizations
```

**Expected Summary**:
```
Overall Performance Improvements:
- Rule matching: 35x faster
- Fact operations: 50x faster
- REPL completion: 60x faster
- Type lookups: 200x faster

Total evaluation pipeline: 15-25x faster for typical workloads
```

---

## Documentation Requirements

### Benchmark Report Template

**File**: `docs/performance_results.md`

```markdown
# MeTTaTron Optimization Performance Results

**Date**: YYYY-MM-DD
**Hardware**: [CPU, RAM, OS]
**Baseline**: main branch (commit: abc123)
**Optimized**: feature/optimizations (commit: def456)

## Summary

| Optimization | Baseline | Optimized | Speedup | Status |
|-------------|----------|-----------|---------|--------|
| Rule Index | 505 µs | 10 µs | 50.5x | ✅ |
| has_sexpr_fact | 1100 µs | 12 µs | 91.7x | ✅ |
| Completion | 550 µs | 9 µs | 61.1x | ✅ |
| ... | ... | ... | ... | ... |

## Detailed Results

[Include Criterion HTML reports]

## Conclusion

All optimizations meet or exceed target speedups.
Ready for merge.
```

---

## Summary

### Benchmarking Checklist

- [ ] Create `benches/metta_optimizations.rs`
- [ ] Implement test data generation helpers
- [ ] Add Criterion.rs to dev-dependencies
- [ ] Benchmark all 7 optimizations
- [ ] Validate speedups meet targets
- [ ] Set up CI benchmark workflow
- [ ] Generate performance report
- [ ] Compare with baseline
- [ ] Document results

**See Also**:
- `metta_pathmap_optimization_proposal.md` - Expected speedups
- `metta_implementation_roadmap.md` - Phase 4 testing details
