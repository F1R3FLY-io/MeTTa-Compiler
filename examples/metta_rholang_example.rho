// =====================================================================
// Example: Using MeTTa Compiler from Rholang
// =====================================================================
// This example demonstrates how to use the MeTTa compiler service
// from Rholang contracts.
// =====================================================================

new stdout(`rho:io:stdout`), stdoutAck(`rho:io:stdoutAck`),
    mettaCompile(`rho:metta:compile`),
    ack, result
in {
  // ===================================================================
  // Example 1: Simple Arithmetic Compilation
  // ===================================================================
  stdoutAck!("=== Example 1: Simple Arithmetic ===", *ack) |
  for (_ <- ack) {
    // Compile a simple MeTTa expression using !? operator
    for (@compiledResult <- mettaCompile!?("(+ 1 2)")) {
      // compiledResult is a PathMap Par with the compiled state
      stdoutAck!(compiledResult, *ack) |
      for (_ <- ack) {
        stdout!("\n")
      }
    }
  } |

  // ===================================================================
  // Example 2: Compiling a Rule Definition
  // ===================================================================
  stdoutAck!("=== Example 2: Rule Definition ===", *ack) |
  for (_ <- ack) {
    for (@compiledResult <- mettaCompile!?("(= (double $x) (* $x 2))")) {
      stdoutAck!(compiledResult, *ack) |
      for (_ <- ack) {
        stdout!("\n")
      }
    }
  } |

  // ===================================================================
  // Example 3: Nested Expressions
  // ===================================================================
  stdoutAck!("=== Example 3: Nested Expression ===", *ack) |
  for (_ <- ack) {
    for (@compiledResult <- mettaCompile!?("(+ 1 (* 2 3))")) {
      stdoutAck!(compiledResult, *ack) |
      for (_ <- ack) {
        stdout!("\n")
      }
    }
  } |

  // ===================================================================
  // Example 4: Error Handling
  // ===================================================================
  stdoutAck!("=== Example 4: Syntax Error ===", *ack) |
  for (_ <- ack) {
    // This will produce an error due to unclosed parenthesis
    for (@compiledResult <- mettaCompile!?("(+ 1 2")) {
      // Result will contain error Par
      stdoutAck!(compiledResult, *ack) |
      for (_ <- ack) {
        stdout!("\n")
      }
    }
  } |

  // ===================================================================
  // Example 5: MeTTa Compiler as a Service
  // ===================================================================
  stdoutAck!("=== Example 5: Compiler Service ===", *ack) |
  for (_ <- ack) {
    // Create a reusable compiler contract using !? operator
    contract @"compileAndPrint"(@source) = {
      for (@result <- mettaCompile!?(source)) {
        stdoutAck!("Compiled: ", *ack) |
        for (_ <- ack) {
          stdoutAck!(result, *ack)
        }
      }
    } |

    // Use the service multiple times
    @"compileAndPrint"!("(+ 1 2)") |
    @"compileAndPrint"!("(* 3 4)") |
    @"compileAndPrint"!("(< 5 10)")
  } |

  // ===================================================================
  // Example 6: Working with PathMap Results
  // ===================================================================
  stdoutAck!("=== Example 6: PathMap Results ===", *ack) |
  for (_ <- ack) {
    contract @"compileAndCheck"(@source, success, error) = {
      for (@result <- mettaCompile!?(source)) {
        // result is now a PathMap Par
        // You can inspect it or pass it to other contracts
        // For demonstration, we'll just send it to success channel
        success!(result)
      }
    } |

    new successChan, errorChan in {
      @"compileAndCheck"!("(+ 1 2)", *successChan, *errorChan) |
      for (@s <- successChan) {
        stdoutAck!("Success (PathMap): ", *ack) |
        for (_ <- ack) {
          stdoutAck!(s, *ack)
        }
      } |
      for (@e <- errorChan) {
        stdoutAck!("Error: ", *ack) |
        for (_ <- ack) {
          stdoutAck!(e, *ack)
        }
      }
    }
  }
}

// =====================================================================
// Expected Output
// =====================================================================
// === Example 1: Simple Arithmetic ===
// {|("source", [("+", 1, 2)]), ("environment", ...), ("output", [])|}
// Note: To evaluate, use {||}.run(compiledResult)
//
// === Example 2: Rule Definition ===
// {|("source", [("=", ...)]), ("environment", ...), ("output", [])|}
//
// === Example 3: Nested Expression ===
// {|("source", [("+", 1, ("*", 2, 3))]), ("environment", ...), ("output", [])|}
//
// === Example 4: Syntax Error ===
// {|("source", []), ("environment", ...), ("output", [("error", "Unexpected EOF", Nil)])|}
//
// === Example 5: Compiler Service ===
// Compiled: {|("source", [("+", 1, 2)]), ...|}
// Compiled: {|("source", [("*", 3, 4)]), ...|}
// Compiled: {|("source", [("<", 5, 10)]), ...|}
//
// === Example 6: PathMap Results ===
// Success (PathMap): {|("source", [("+", 1, 2)]), ("environment", ...), ("output", [])|}
// Note: To get evaluated results, use .run() method
