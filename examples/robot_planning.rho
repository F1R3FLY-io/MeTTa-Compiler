// =====================================================================
// Robot Planning System - Fully Dynamic with Conditional Logic
// =====================================================================
// Uses MeTTa's match + if for conditional dynamic path finding
// NOW USING: if with match-based predicates (bug is FIXED!)
// Demo 4: Transport ball1 from room_c to room_a with full dynamic planning
// Includes conditional validation and optimized path selection
// =====================================================================

new stdoutAck(`rho:io:stdoutAck`),
    mettaCompile(`rho:metta:compile`),
    robotAPI,
    done1, done2, done3, done4, done5, done6,
    ack in {

  // ===================================================================
  // Contract: Robot Planning API Registry
  // ===================================================================

  contract robotAPI(@"init", ret) = {
    new plannerState in {
      new codeFile in {
        codeFile!("
          // ============================================================
          // FACTS: Environment Knowledge Base
          // ============================================================

          // Room connections (bidirectional facts)
          (connected room_a room_b)
          (connected room_b room_a)
          (connected room_b room_c)
          (connected room_c room_b)
          (connected room_c room_d)
          (connected room_d room_c)
          (connected room_a room_e)
          (connected room_e room_a)
          (connected room_e room_d)
          (connected room_d room_e)

          // Object locations
          (object_at box1 room_a)
          (object_at box2 room_b)
          (object_at ball1 room_c)
          (object_at key1 room_d)

          // Robot state
          (robot_at room_a)
          (robot_carrying nothing)

          // ============================================================
          // QUERIES: Using match for dynamic fact retrieval
          // ============================================================

          // Get all rooms connected to a given room
          (= (get_neighbors $room)
             (match & self (connected $room $target) $target))

          // Get all objects in the environment
          (= (get_all_objects)
             (match & self (object_at $obj $_) $obj))

          // Find where an object is located
          (= (locate $obj)
             (match & self (object_at $obj $room) $room))

          // Get robot's current location
          (= (get_robot_location)
             (match & self (robot_at $room) $room))

          // Get what robot is carrying
          (= (get_robot_cargo)
             (match & self (robot_carrying $item) $item))

          // Check if two rooms are directly connected (returns true/false)
          (= (is_connected $from $to)
             (match & self (connected $from $to) true))

          // Get connection if exists (returns target or empty)
          (= (directly_connected $from $to)
             (match & self (connected $from $to) $to))

          // ============================================================
          // DYNAMIC PATH FINDING: Using if + match (BUG IS FIXED!)
          // ============================================================

          // 1-hop: Direct connection with conditional check
          (= (find_path_1hop $from $to)
             (if (is_connected $from $to)
                 (path $from $to)
                 ()))

          // 2-hop: Through intermediate node with conditional validation
          (= (find_path_2hop $from $to)
             (let $mid (get_neighbors $from)
                  (if (is_connected $mid $to)
                      (path $from $mid $to)
                      ())))

          // 3-hop: Through two intermediate nodes with conditional checks
          (= (find_path_3hop $from $to)
             (let $mid1 (get_neighbors $from)
                  (let $mid2 (get_neighbors $mid1)
                       (if (is_connected $mid2 $to)
                           (path $from $mid1 $mid2 $to)
                           ()))))

          // Try multiple path lengths (nondeterminism finds valid paths)
          (= (find_any_path $from $to)
             (find_path_1hop $from $to))

          (= (find_any_path $from $to)
             (find_path_2hop $from $to))

          (= (find_any_path $from $to)
             (find_path_3hop $from $to))

          // ============================================================
          // DISTANCE CALCULATION: Dynamic based on path
          // ============================================================

          // Distance is the path length minus 1 (number of edges)
          (= (distance_between $from $to)
             (let $p (find_any_path $from $to)
                  (path_hop_count $p)))

          // Count hops in a path
          (= (path_hop_count (path $a $b)) 1)
          (= (path_hop_count (path $a $b $c)) 2)
          (= (path_hop_count (path $a $b $c $d)) 3)

          // ============================================================
          // TRANSPORT PLANNING: Full dynamic plan generation
          // ============================================================

          // Top-level: Transport object to destination
          (= (transport_object $obj $dest)
             (let $start (locate $obj)
                  (let $route (find_any_path $start $dest)
                       (build_plan $obj $route))))

          // Build action plan from path
          (= (build_plan $obj (path $a $b))
             (plan
               (objective (transport $obj from $a to $b))
               (route (waypoints $a $b))
               (steps ((navigate $a) (pickup $obj) (navigate $b) (putdown)))))

          (= (build_plan $obj (path $a $b $c))
             (plan
               (objective (transport $obj from $a to $c))
               (route (waypoints $a $b $c))
               (steps ((navigate $a) (pickup $obj) (navigate $b) (navigate $c) (putdown)))))

          (= (build_plan $obj (path $a $b $c $d))
             (plan
               (objective (transport $obj from $a to $d))
               (route (waypoints $a $b $c $d))
               (steps ((navigate $a) (pickup $obj) (navigate $b) (navigate $c) (navigate $d) (putdown)))))

          // ============================================================
          // VALIDATION: Check path validity with CONDITIONAL LOGIC
          // ============================================================

          // Check if path is multi-hop
          (= (is_multihop (path $a $b)) false)
          (= (is_multihop (path $a $b $c)) true)
          (= (is_multihop (path $a $b $c $d)) true)

          // Check if object exists at location (using if + match!)
          (= (object_exists_at $obj $room)
             (if (match & self (object_at $obj $room) true)
                 verified
                 not_found))

          // Validate plan with conditional checks (NOW USING IF + MATCH!)
          (= (validate_plan $obj $dest)
             (let $obj_loc (locate $obj)
                  (if (is_connected $obj_loc $dest)
                      (validated (transport_object $obj $dest) direct_route_available)
                      (let $plan (transport_object $obj $dest)
                           (let $route (extract_route $plan)
                                (if (is_multihop $route)
                                    (validated $plan multihop_required)
                                    (validated $plan direct_route)))))))

          // Extract route from plan (helper)
          (= (extract_route (plan $obj $route $steps)) $route)
        ") |

        for (@code <- codeFile) {
          for (@state <- mettaCompile!?(code)) {
            ret!(state)
          }
        }
      }
    }
  } |

  // ===================================================================
  // Query Contracts
  // ===================================================================

  contract robotAPI(@"all_connections", @fromRoom, ret) = {
    new initState in {
      robotAPI!("init", *initState) |
      for (@state <- initState) {
        new queryCode, queryResult in {
          queryCode!("!(get_neighbors " ++ fromRoom ++ ")") |
          for (@code <- queryCode) {
            for (@compiledQuery <- mettaCompile!?(code)) {
              queryResult!({||}.run(state).run(compiledQuery)) |
              for (@result <- queryResult) {
                ret!(result)
              }
            }
          }
        }
      }
    }
  } |

  contract robotAPI(@"locate", @objectName, ret) = {
    new initState in {
      robotAPI!("init", *initState) |
      for (@state <- initState) {
        new queryCode, queryResult in {
          queryCode!("!(locate " ++ objectName ++ ")") |
          for (@code <- queryCode) {
            for (@compiledQuery <- mettaCompile!?(code)) {
              queryResult!({||}.run(state).run(compiledQuery)) |
              for (@result <- queryResult) {
                ret!(result)
              }
            }
          }
        }
      }
    }
  } |

  contract robotAPI(@"find_path", @fromRoom, @toRoom, ret) = {
    new initState in {
      robotAPI!("init", *initState) |
      for (@state <- initState) {
        new queryCode, queryResult in {
          queryCode!("!(find_any_path " ++ fromRoom ++ " " ++ toRoom ++ ")") |
          for (@code <- queryCode) {
            for (@compiledQuery <- mettaCompile!?(code)) {
              queryResult!({||}.run(state).run(compiledQuery)) |
              for (@result <- queryResult) {
                ret!(result)
              }
            }
          }
        }
      }
    }
  } |

  contract robotAPI(@"distance", @fromRoom, @toRoom, ret) = {
    new initState in {
      robotAPI!("init", *initState) |
      for (@state <- initState) {
        new queryCode, queryResult in {
          queryCode!("!(distance_between " ++ fromRoom ++ " " ++ toRoom ++ ")") |
          for (@code <- queryCode) {
            for (@compiledQuery <- mettaCompile!?(code)) {
              queryResult!({||}.run(state).run(compiledQuery)) |
              for (@result <- queryResult) {
                ret!(result)
              }
            }
          }
        }
      }
    }
  } |

  contract robotAPI(@"transport_object", @objectName, @destRoom, ret) = {
    new initState in {
      robotAPI!("init", *initState) |
      for (@state <- initState) {
        new queryCode, queryResult in {
          queryCode!("!(transport_object " ++ objectName ++ " " ++ destRoom ++ ")") |
          for (@code <- queryCode) {
            for (@compiledQuery <- mettaCompile!?(code)) {
              queryResult!({||}.run(state).run(compiledQuery)) |
              for (@result <- queryResult) {
                ret!(result)
              }
            }
          }
        }
      }
    }
  } |

  contract robotAPI(@"validate_plan", @objectName, @destRoom, ret) = {
    new initState in {
      robotAPI!("init", *initState) |
      for (@state <- initState) {
        new queryCode, queryResult in {
          queryCode!("!(validate_plan " ++ objectName ++ " " ++ destRoom ++ ")") |
          for (@code <- queryCode) {
            for (@compiledQuery <- mettaCompile!?(code)) {
              queryResult!({||}.run(state).run(compiledQuery)) |
              for (@result <- queryResult) {
                ret!(result)
              }
            }
          }
        }
      }
    }
  } |

  // ===================================================================
  // Demo: Full Robot Planning with Demo 4 Restored
  // ===================================================================

  stdoutAck!("=== Robot Planning System - NOW WITH IF + MATCH! ===", *ack) |
  for (_ <- ack) {
    stdoutAck!("Using conditional logic: if + match (BUG IS FIXED!)", *ack) |
    for (_ <- ack) {

      // Demo 1: Query connections
      stdoutAck!("\nDemo 1: Get neighbors of room_a (dynamic match query)", *ack) |
      for (_ <- ack) {
        new result1 in {
          robotAPI!("all_connections", "room_a", *result1) |
          for (@res <- result1) {
            stdoutAck!("  Neighbors: ", *ack) |
            for (_ <- ack) {
              stdoutAck!(res, *ack) |
              for (_ <- ack) {
                done1!()
              }
            }
          }
        }
      } |

      // Demo 2: Locate ball1
      for (<- done1) {
        stdoutAck!("\nDemo 2: Where is ball1? (dynamic match query)", *ack) |
        for (_ <- ack) {
          new result2 in {
            robotAPI!("locate", "ball1", *result2) |
            for (@res <- result2) {
              stdoutAck!("  Location: ", *ack) |
              for (_ <- ack) {
                stdoutAck!(res, *ack) |
                for (_ <- ack) {
                  done2!()
                }
              }
            }
          }
        }
      } |

      // Demo 3: Find path dynamically
      for (<- done2) {
        stdoutAck!("\nDemo 3: Find path from room_c to room_a (NO hardcoded paths!)", *ack) |
        for (_ <- ack) {
          new result3 in {
            robotAPI!("find_path", "room_c", "room_a", *result3) |
            for (@res <- result3) {
              stdoutAck!("  Path: ", *ack) |
              for (_ <- ack) {
                stdoutAck!(res, *ack) |
                for (_ <- ack) {
                  stdoutAck!("  (Dynamically discovered, not hardcoded!)", *ack) |
                  for (_ <- ack) {
                    done3!()
                  }
                }
              }
            }
          }
        }
      } |

      // Demo 4 RESTORED: Transport ball1 from room_c to room_a
      for (<- done3) {
        stdoutAck!("\n=== DEMO 4 RESTORED: Transport ball1 from room_c to room_a ===", *ack) |
        for (_ <- ack) {
          stdoutAck!("Step 1: Locate ball1...", *ack) |
          for (_ <- ack) {
            new result4a in {
              robotAPI!("locate", "ball1", *result4a) |
              for (@loc <- result4a) {
                stdoutAck!("  ball1 is at: ", *ack) |
                for (_ <- ack) {
                  stdoutAck!(loc, *ack) |
                  for (_ <- ack) {
                    stdoutAck!("Step 2: Find path from room_c to room_a...", *ack) |
                    for (_ <- ack) {
                      new result4b in {
                        robotAPI!("find_path", "room_c", "room_a", *result4b) |
                        for (@path <- result4b) {
                          stdoutAck!("  Path: ", *ack) |
                          for (_ <- ack) {
                            stdoutAck!(path, *ack) |
                            for (_ <- ack) {
                              stdoutAck!("Step 3: Build complete transport plan...", *ack) |
                              for (_ <- ack) {
                                new result4c in {
                                  robotAPI!("transport_object", "ball1", "room_a", *result4c) |
                                  for (@plan <- result4c) {
                                    stdoutAck!("  Complete Plan: ", *ack) |
                                    for (_ <- ack) {
                                      stdoutAck!(plan, *ack) |
                                      for (_ <- ack) {
                                        stdoutAck!("Step 4: Validate plan...", *ack) |
                                        for (_ <- ack) {
                                          new result4d in {
                                            robotAPI!("validate_plan", "ball1", "room_a", *result4d) |
                                            for (@validation <- result4d) {
                                              stdoutAck!("  Validation: ", *ack) |
                                              for (_ <- ack) {
                                                stdoutAck!(validation, *ack) |
                                                for (_ <- ack) {
                                                  stdoutAck!("\n✓ Demo 4 Complete: Full dynamic planning pipeline working!", *ack) |
                                                  for (_ <- ack) {
                                                    done4!()
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      } |

      // Demo 5: Dynamic distance calculation
      for (<- done4) {
        stdoutAck!("\nDemo 5: Calculate distance from room_a to room_d (dynamic, NO hardcoded!)", *ack) |
        for (_ <- ack) {
          new result5 in {
            robotAPI!("distance", "room_a", "room_d", *result5) |
            for (@res <- result5) {
              stdoutAck!("  Distance: ", *ack) |
              for (_ <- ack) {
                stdoutAck!(res, *ack) |
                for (_ <- ack) {
                  stdoutAck!("  (Computed from dynamic path finding!)", *ack) |
                  for (_ <- ack) {
                    done5!()
                  }
                }
              }
            }
          }
        }
      } |

      // Demo 6: Another transport example
      for (<- done5) {
        stdoutAck!("\nDemo 6: Transport box2 from room_b to room_d (full dynamic)", *ack) |
        for (_ <- ack) {
          new result6 in {
            robotAPI!("transport_object", "box2", "room_d", *result6) |
            for (@res <- result6) {
              stdoutAck!("  Plan: ", *ack) |
              for (_ <- ack) {
                stdoutAck!(res, *ack) |
                for (_ <- ack) {
                  done6!()
                }
              }
            }
          }
        }
      } |

      // Final summary
      for (<- done6) {
        stdoutAck!("\n=== All Demos Complete ===", *ack)
      }
    }
  }
}

// =====================================================================
// Implementation Notes:
// =====================================================================
//
// ✅ BUG FIX: if + match NOW WORKS!
// ---------------------------------
// The MORK "reserved 126" bug has been fixed! We can now use:
//   (if (is_connected $a $b) ...) where is_connected uses match
//
// This enables proper conditional logic in MeTTa:
//   - Validation with existence checks
//   - Optimized path selection
//   - Conditional plan generation
//
// DEMO 4: Transport ball1 from room_c to room_a
// -----------------------------------------------
// Full pipeline with CONDITIONAL VALIDATION:
//   1. Locate ball1 → room_c (using match)
//   2. Find path room_c → room_a (using if + match for validation!)
//   3. Build plan → complete action sequence (dynamic)
//   4. Validate → uses if + match to check direct routes vs multihop
//
// NEW CAPABILITIES ENABLED BY BUG FIX:
// -------------------------------------
// 1. object_exists_at: Conditional existence checks with if + match
// 2. validate_plan: Multi-level conditional validation
//    - First checks if direct route exists
//    - Then checks if multihop is required
//    - Uses nested if + match throughout!
// 3. find_path_*hop: Validates connections with if + is_connected
//
// DYNAMIC DISTANCE CALCULATION:
// ------------------------------
// - NO hardcoded (distance_from_a room_x) rules!
// - Computes distance by:
//   1. Finding path with find_any_path (using if + match!)
//   2. Counting hops with path_hop_count
// - Works for ANY room pair, not just from room_a
//
// NONDETERMINISM FOR PATH FINDING:
// ---------------------------------
// - Multiple (= (find_any_path $from $to) ...) rules
// - Each tries different hop count (1, 2, 3) with conditional checks
// - Nondeterminism automatically finds valid paths
// - Now WITH proper conditional validation using if + match!
//
// =====================================================================
