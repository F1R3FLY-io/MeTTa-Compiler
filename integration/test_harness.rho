// =====================================================================
// MeTTaTron Test Harness for Rholang Integration
// =====================================================================
// Comprehensive test suite for MeTTa compiler and evaluator
// =====================================================================

new stdout(`rho:io:stdout`),
    stdoutAck(`rho:io:stdoutAck`),
    mettaCompile(`rho:metta:compile`),
    runMeTTa,
    testHarness,
    runTestSuite,
    done1, done2, done3, done4, done5, done6, done7, done8, done9, done10, done11, done12, done13, done14, done15,
    ack in {

  // ===================================================================
  // Core Contracts
  // ===================================================================

  /**
   * runMeTTa: Compile and evaluate MeTTa code
   * @param ret - Return channel for result
   * @param src - Source channel for MeTTa code
   */
  contract runMeTTa(ret, src) = {
    for (@code <= src) {
      new compiledState in {
        mettaCompile!(*compiledState, code) |
        for (@pm <- compiledState) {
          // Run compiled state against empty accumulated state
          new result in {
            result!({||}.run(pm)) |
            for (@accumulated <- result) {
              ret!(accumulated)
            }
          }
        }
      }
    }
  } |

  /**
   * testHarness: Run a single test with multiple MeTTa expressions
   * @param testName - Name of the test
   * @param src - Source channel for MeTTa code
   * @param expectedCount - Expected number of outputs (for display only)
   */
  contract testHarness(@testName, src, @expectedCount, done) = {
    new srcChan, resultChan in {
      stdoutAck!("Test: " ++ testName ++ "\n", *ack) |
      for (_ <- ack) {
        stdoutAck!("  Expected outputs: ", *ack) |
        for (_ <- ack) {
          stdoutAck!(expectedCount, *ack) |
          for (_ <- ack) {
            stdoutAck!("\n", *ack) |
            for (_ <- ack) {
              // Feed all MeTTa code into source channel
              for (@code <= src) {
                srcChan!(code)
              } |

              // Run MeTTa and collect result
              runMeTTa!(*resultChan, *srcChan) |
              for (@result <- resultChan) {
                stdoutAck!("  Result: ", *ack) |
                for (_ <- ack) {
                  stdoutAck!(result, *ack) |
                  for (_ <- ack) {
                    stdoutAck!("\n\n", *ack) |
                    for (_ <- ack) {
                      done!()
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  } |

  // ===================================================================
  // Test Suite
  // ===================================================================

  contract runTestSuite(@_) = {
    stdoutAck!("=== MeTTaTron Test Harness ===\n\n", *ack) |

    // Test 1: Basic Arithmetic
    for (_ <- ack) {
      new src in {
        src!("!(+ 1 2)") |
        testHarness!("Basic arithmetic: (+ 1 2)", *src, 1, *done1)
      }
    } |

    // Test 2: Nested Arithmetic
    for (<- done1) {
      new src in {
        src!("!(+ 1 (* 2 3))") |
        testHarness!("Nested arithmetic: (+ 1 (* 2 3))", *src, 1, *done2)
      }
    } |

    // Test 3: Multiple Expressions
    for (<- done2) {
      new src in {
        src!("!(+ 1 2)") |
        src!("!(* 3 4)") |
        src!("!(- 10 5)") |
        testHarness!("Multiple expressions", *src, 3, *done3)
      }
    } |

    // Test 4: Rule Definition
    for (<- done3) {
      new src in {
        src!("(= (double $x) (* $x 2))") |
        testHarness!("Rule definition: double", *src, 0, *done4)
      }
    } |

    // Test 5: Rule Usage (Sequential)
    for (<- done4) {
      stdoutAck!("Test: Rule usage (sequential)\n", *ack) |
      for (_ <- ack) {
        new src1, result1, src2, result2 in {
          // Step 1: Define rule
          src1!("(= (triple $x) (* $x 3))") |
          runMeTTa!(*result1, *src1) |
          for (@accumulated1 <- result1) {
            stdoutAck!("  Step 1 - Rule defined: ", *ack) |
            for (_ <- ack) {
              stdoutAck!(accumulated1, *ack) |
              for (_ <- ack) {
                stdoutAck!("\n", *ack) |
                for (_ <- ack) {
                  // Step 2: Use rule (run against accumulated state)
                  new useCompiled in {
                    mettaCompile!(*useCompiled, "!(triple 7)") |
                    for (@compiledUse <- useCompiled) {
                      new finalResult in {
                        finalResult!(accumulated1.run(compiledUse)) |
                        for (@accumulated2 <- finalResult) {
                          stdoutAck!("  Step 2 - Rule used: ", *ack) |
                          for (_ <- ack) {
                            stdoutAck!(accumulated2, *ack) |
                            for (_ <- ack) {
                              stdoutAck!("\n\n", *ack) |
                              for (_ <- ack) {
                                done5!()
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    } |

    // Test 6: Boolean Operations
    for (<- done5) {
      new src in {
        src!("!(< 1 2)") |
        src!("!(> 5 3)") |
        src!("!(== 4 4)") |
        testHarness!("Boolean operations", *src, 3, *done6)
      }
    } |

    // Test 7: Quote and Eval
    for (<- done6) {
      new src in {
        src!("!(quote (+ 1 2))") |
        testHarness!("Quote expression", *src, 1, *done7)
      }
    } |

    // Test 8: Error Handling
    for (<- done7) {
      new src in {
        src!("!(error \"test error\" 42)") |
        testHarness!("Error handling", *src, 1, *done8)
      }
    } |

    // Test 9: Catch Expression
    for (<- done8) {
      new src in {
        src!("!(catch (error \"test\" 0) \"recovered\")") |
        testHarness!("Catch expression", *src, 1, *done9)
      }
    } |

    // Test 10: Conditional (if)
    for (<- done9) {
      new src in {
        src!("!(if (< 1 2) \"yes\" \"no\")") |
        testHarness!("Conditional if (true case)", *src, 1, *done10)
      }
    } |

    // Test 11: Multiple Rule Definitions
    for (<- done10) {
      stdoutAck!("Test: Multiple rules with chaining\n", *ack) |
      for (_ <- ack) {
        new src1, result1 in {
          // Define double rule
          src1!("(= (double $x) (* $x 2))") |
          runMeTTa!(*result1, *src1) |
          for (@accumulated1 <- result1) {
            stdoutAck!("  Step 1 - double rule defined\n", *ack) |
            for (_ <- ack) {
              // Define quadruple rule (uses double)
              new src2, useCompiled2 in {
                mettaCompile!(*useCompiled2, "(= (quadruple $x) (double (double $x)))") |
                for (@compiled2 <- useCompiled2) {
                  new result2 in {
                    result2!(accumulated1.run(compiled2)) |
                    for (@accumulated2 <- result2) {
                      stdoutAck!("  Step 2 - quadruple rule defined\n", *ack) |
                      for (_ <- ack) {
                        // Use quadruple rule
                        new useCompiled3 in {
                          mettaCompile!(*useCompiled3, "!(quadruple 3)") |
                          for (@compiled3 <- useCompiled3) {
                            new result3 in {
                              result3!(accumulated2.run(compiled3)) |
                              for (@accumulated3 <- result3) {
                                stdoutAck!("  Step 3 - Final result: ", *ack) |
                                for (_ <- ack) {
                                  stdoutAck!(accumulated3, *ack) |
                                  for (_ <- ack) {
                                    stdoutAck!("\n\n", *ack) |
                                    for (_ <- ack) {
                                      done11!()
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    } |

    // Test 12: REPL Simulation (Multiple Sequential Evaluations)
    for (<- done11) {
      stdoutAck!("Test: REPL simulation (accumulate multiple evaluations)\n", *ack) |
      for (_ <- ack) {
        new src1, result1 in {
          src1!("!(+ 10 5)") |
          runMeTTa!(*result1, *src1) |
          for (@acc1 <- result1) {
            stdoutAck!("  Input 1: (+ 10 5)\n", *ack) |
            for (_ <- ack) {
              new useCompiled2 in {
                mettaCompile!(*useCompiled2, "!(* 3 4)") |
                for (@compiled2 <- useCompiled2) {
                  new result2 in {
                    result2!(acc1.run(compiled2)) |
                    for (@acc2 <- result2) {
                      stdoutAck!("  Input 2: (* 3 4)\n", *ack) |
                      for (_ <- ack) {
                        new useCompiled3 in {
                          mettaCompile!(*useCompiled3, "!(- 20 10)") |
                          for (@compiled3 <- useCompiled3) {
                            new result3 in {
                              result3!(acc2.run(compiled3)) |
                              for (@acc3 <- result3) {
                                stdoutAck!("  Input 3: (- 20 10)\n", *ack) |
                                for (_ <- ack) {
                                  stdoutAck!("  Final accumulated state: ", *ack) |
                                  for (_ <- ack) {
                                    stdoutAck!(acc3, *ack) |
                                    for (_ <- ack) {
                                      stdoutAck!("\n\n", *ack) |
                                      for (_ <- ack) {
                                        done12!()
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    } |

    // Test 13: Division Operations
    for (<- done12) {
      new src in {
        src!("!(/ 10 2)") |
        src!("!(/ 7 3)") |
        testHarness!("Division operations", *src, 2, *done13)
      }
    } |

    // Test 14: Complex Nested Expression
    for (<- done13) {
      new src in {
        src!("!(+ (* 2 3) (- 10 5))") |
        testHarness!("Complex nested: (+ (* 2 3) (- 10 5))", *src, 1, *done14)
      }
    } |

    // Test 15: Type System (if available)
    for (<- done14) {
      new src in {
        src!("(: x Number)") |
        testHarness!("Type assertion", *src, 0, *done15)
      }
    } |

    // Final Summary
    for (<- done15) {
      stdoutAck!("=== Test Suite Complete ===\n", *ack)
    }
  } |

  // ===================================================================
  // Start Test Suite
  // ===================================================================

  runTestSuite!(Nil)
}
