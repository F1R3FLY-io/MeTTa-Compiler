// =====================================================================
// MeTTaTron Composability Test Suite
// =====================================================================
// Comprehensive tests for .run() method composability properties
// Based on Rust tests in rholang_integration.rs
// =====================================================================

new stdoutAck(`rho:io:stdoutAck`),
    mettaCompile(`rho:metta:compile`),
    runMeTTa,
    runTest,
    ack in {

  // ===================================================================
  // Helper Contract
  // ===================================================================

  contract runMeTTa(ret, @code) = {
    new compiledState in {
      mettaCompile!(*compiledState, code) |
      for (@pm <- compiledState) {
        new result in {
          result!({||}.run(pm)) |
          for (@rslt <- result) {
            ret!(rslt)
          }
        }
      }
    }
  } |

  // ===================================================================
  // Test Suite: Composability Properties
  // ===================================================================

  stdoutAck!("=== MeTTaTron Composability Test Suite ===\n\n", *ack) |

  // -------------------------------------------------------------------
  // Test 1: Identity Property
  // Running against empty state should work like first run
  // -------------------------------------------------------------------
  for (ret, @"1" <- runTest) {
    stdoutAck!("Test 1: Identity - empty.run(compiled) behaves as initial run\n", *ack) |
    for (_ <- ack) {
      new result in {
        runMeTTa!(*result, "!(+ 5 7)") |
        for (@state <- result) {
          stdoutAck!("  Result: ", *ack) |
          for (_ <- ack) {
            stdoutAck!(state, *ack) |
            for (_ <- ack) {
              stdoutAck!("\n  Expected: eval_outputs should contain [12]\n\n", *ack) |
              for (_ <- ack) {
                ret!()
              }
            }
          }
        }
      }
    }
  } |

  // -------------------------------------------------------------------
  // Test 2: Sequential Composition
  // state.run(a).run(b).run(c) accumulates all results
  // -------------------------------------------------------------------
  for (ret, @"2" <- runTest) {
    stdoutAck!("Test 2: Sequential Composition - s.run(a).run(b).run(c)\n", *ack) |
    for (_ <- ack) {
      new r0 in {
        runMeTTa!(*r0, "!(+ 1 2)") |
        for (@s1 <- r0) {
          stdoutAck!("  After run(a): state has 1 output\n", *ack) |
          for (_ <- ack) {
            new c2, r1 in {
              mettaCompile!(*c2, "!(* 3 4)") |
              for (@compiled2 <- c2) {
                r1!(s1.run(compiled2)) |
                for (@s2 <- r1) {
                  stdoutAck!("  After run(b): state has 2 outputs\n", *ack) |
                  for (_ <- ack) {
                    new c3, r2 in {
                      mettaCompile!(*c3, "!(- 10 5)") |
                      for (@compiled3 <- c3) {
                        r2!(s2.run(compiled3)) |
                        for (@s3 <- r2) {
                          stdoutAck!("  After run(c): ", *ack) |
                          for (_ <- ack) {
                            stdoutAck!(s3, *ack) |
                            for (_ <- ack) {
                              stdoutAck!("\n  Expected: 3 outputs [3, 12, 5]\n\n", *ack) |
                              for (_ <- ack) {
                                ret!()
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  } |

  // -------------------------------------------------------------------
  // Test 3: Rule Persistence
  // Rules defined in earlier runs are available in later runs
  // -------------------------------------------------------------------
  for (ret, @"3" <- runTest) {
    stdoutAck!("Test 3: Rule Persistence - rules accumulate across runs\n", *ack) |
    for (_ <- ack) {
      new r1 in {
        runMeTTa!(*r1, "(= (double $x) (* $x 2))") |
        for (@s1 <- r1) {
          stdoutAck!("  Step 1: Defined 'double' rule\n", *ack) |
          for (_ <- ack) {
            new c2, r2 in {
              mettaCompile!(*c2, "(= (triple $x) (* $x 3))") |
              for (@compiled2 <- c2) {
                r2!(s1.run(compiled2)) |
                for (@s2 <- r2) {
                  stdoutAck!("  Step 2: Defined 'triple' rule\n", *ack) |
                  for (_ <- ack) {
                    new c3, r3 in {
                      mettaCompile!(*c3, "!(double 5) !(triple 5)") |
                      for (@compiled3 <- c3) {
                        r3!(s2.run(compiled3)) |
                        for (@s3 <- r3) {
                          stdoutAck!("  Step 3: Used both rules: ", *ack) |
                          for (_ <- ack) {
                            stdoutAck!(s3, *ack) |
                            for (_ <- ack) {
                              stdoutAck!("\n  Expected: 2 outputs [10, 15] (rule defs produce no output)\n\n", *ack) |
                              for (_ <- ack) {
                                ret!()
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  } |

  // -------------------------------------------------------------------
  // Test 4: Rule Chaining
  // Rules can use other rules defined earlier
  // -------------------------------------------------------------------
  for (ret, @"4" <- runTest) {
    stdoutAck!("Test 4: Rule Chaining - rules using other rules\n", *ack) |
    for (_ <- ack) {
      new r1 in {
        runMeTTa!(*r1, "(= (double $x) (* $x 2))") |
        for (@s1 <- r1) {
          stdoutAck!("  Step 1: Defined 'double'\n", *ack) |
          for (_ <- ack) {
            new c2, r2 in {
              mettaCompile!(*c2, "(= (quadruple $x) (double (double $x)))") |
              for (@compiled2 <- c2) {
                r2!(s1.run(compiled2)) |
                for (@s2 <- r2) {
                  stdoutAck!("  Step 2: Defined 'quadruple' (uses double)\n", *ack) |
                  for (_ <- ack) {
                    new c3, r3 in {
                      mettaCompile!(*c3, "!(quadruple 3)") |
                      for (@compiled3 <- c3) {
                        r3!(s2.run(compiled3)) |
                        for (@s3 <- r3) {
                          stdoutAck!("  Step 3: Used quadruple: ", *ack) |
                          for (_ <- ack) {
                            stdoutAck!(s3, *ack) |
                            for (_ <- ack) {
                              stdoutAck!("\n  Expected: quadruple 3 = double(double 3) = double 6 = 12\n\n", *ack) |
                              for (_ <- ack) {
                                ret!()
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  } |

  // -------------------------------------------------------------------
  // Test 5: State Independence
  // Same compiled state can run against different accumulated states
  // -------------------------------------------------------------------
  for (ret, @"5" <- runTest) {
    stdoutAck!("Test 5: State Independence - same compiled, different accumulated\n", *ack) |
    for (_ <- ack) {
      new compileOnce, stateA, stateB in {
        mettaCompile!(*compileOnce, "!(+ 10 20)") |
        for (@compiled <- compileOnce) {
          stdoutAck!("  Compiled once: (+ 10 20)\n", *ack) |
          for (_ <- ack) {
            // Run against empty state A
            new resultA in {
              resultA!({||}.run(compiled)) |
              for (@resA <- resultA) {
                stdoutAck!("  State A (empty): ", *ack) |
                for (_ <- ack) {
                  stdoutAck!(resA, *ack) |
                  for (_ <- ack) {
                    stdoutAck!("\n", *ack) |
                    for (_ <- ack) {
                      // Run against empty state B (independent)
                      new resultB in {
                        resultB!({||}.run(compiled)) |
                        for (@resB <- resultB) {
                          stdoutAck!("  State B (empty): ", *ack) |
                          for (_ <- ack) {
                            stdoutAck!(resB, *ack) |
                            for (_ <- ack) {
                              stdoutAck!("\n  Expected: Both produce same result [30]\n\n", *ack)
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  } |

  // -------------------------------------------------------------------
  // Test 6: Monotonic Accumulation
  // Output count never decreases, only increases
  // -------------------------------------------------------------------
  for (ret, @"6" <- runTest) {
    stdoutAck!("Test 6: Monotonic Accumulation - outputs never decrease\n", *ack) |
    for (_ <- ack) {
      new r1 in {
        runMeTTa!(*r1, "!(+ 1 1)") |
        for (@s1 <- r1) {
          stdoutAck!("  After 1 run: 1 output\n", *ack) |
          for (_ <- ack) {
            new c2, r2 in {
              mettaCompile!(*c2, "!(+ 2 2)") |
              for (@compiled2 <- c2) {
                r2!(s1.run(compiled2)) |
                for (@s2 <- r2) {
                  stdoutAck!("  After 2 runs: 2 outputs\n", *ack) |
                  for (_ <- ack) {
                    new c3, r3 in {
                      mettaCompile!(*c3, "!(+ 3 3)") |
                      for (@compiled3 <- c3) {
                        r3!(s2.run(compiled3)) |
                        for (@s3 <- r3) {
                          stdoutAck!("  After 3 runs: ", *ack) |
                          for (_ <- ack) {
                            stdoutAck!(s3, *ack) |
                            for (_ <- ack) {
                              stdoutAck!("\n  Expected: 3 outputs [2, 4, 6]\n\n", *ack) |
                              for (_ <- ack) {
                                ret!()
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  } |

  // -------------------------------------------------------------------
  // Test 7: Error Resilience
  // Errors don't break subsequent runs
  // -------------------------------------------------------------------
  for (ret, @"7" <- runTest) {
    stdoutAck!("Test 7: Error Resilience - errors don't break chain\n", *ack) |
    for (_ <- ack) {
      new r1 in {
        runMeTTa!(*r1, "!(+ 1 2)") |
        for (@s1 <- r1) {
          stdoutAck!("  Step 1: Success !(+ 1 2)\n", *ack) |
          for (_ <- ack) {
            new c2, r2 in {
              mettaCompile!(*c2, "!(error \"test\" 0)") |
              for (@compiled2 <- c2) {
                r2!(s1.run(compiled2)) |
                for (@s2 <- r2) {
                  stdoutAck!("  Step 2: Error inserted\n", *ack) |
                  for (_ <- ack) {
                    new c3, r3 in {
                      mettaCompile!(*c3, "!(+ 5 5)") |
                      for (@compiled3 <- c3) {
                        r3!(s2.run(compiled3)) |
                        for (@s3 <- r3) {
                          stdoutAck!("  Step 3: Continue after error: ", *ack) |
                          for (_ <- ack) {
                            stdoutAck!(s3, *ack) |
                            for (_ <- ack) {
                              stdoutAck!("\n  Expected: 3 outputs [3, error, 10]\n\n", *ack) |
                              for (_ <- ack) {
                                ret!()
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  } |

  // -------------------------------------------------------------------
  // Test 8: Multiple Expressions per Run
  // A single .run() can evaluate multiple expressions
  // -------------------------------------------------------------------
  for (ret, @"8" <- runTest) {
    stdoutAck!("Test 8: Multiple Expressions - multiple exprs in single run\n", *ack) |
    for (_ <- ack) {
      new result in {
        runMeTTa!(*result, "!(+ 1 2) !(* 3 4) !(- 10 5)") |
        for (@state <- result) {
          stdoutAck!("  Result: ", *ack) |
          for (_ <- ack) {
            stdoutAck!(state, *ack) |
            for (_ <- ack) {
              stdoutAck!("\n  Expected: 3 outputs from single run [3, 12, 5]\n\n", *ack) |
              for (_ <- ack) {
                ret!()
              }
            }
          }
        }
      }
    }
  } |

  // -------------------------------------------------------------------
  // Test 9: Cross-Contamination Prevention
  // Independent state chains don't affect each other
  // -------------------------------------------------------------------
  for (ret, @"9" <- runTest) {
    stdoutAck!("Test 9: No Cross-Contamination - independent chains separate\n", *ack) |
    for (_ <- ack) {
      new rA1, rB1 in {
        // Chain A: Define 'double'
        runMeTTa!(*rA1, "(= (double $x) (* $x 2))") |
        for (@stateA1 <- rA1) {
          stdoutAck!("  Chain A: Defined 'double'\n", *ack) |
          for (_ <- ack) {
            // Chain B: Define 'triple' (independent)
            runMeTTa!(*rB1, "(= (triple $x) (* $x 3))") |
            for (@stateB1 <- rB1) {
              stdoutAck!("  Chain B: Defined 'triple' (independent)\n", *ack) |
              for (_ <- ack) {
                // Use double in Chain A
                new cA2, rA2 in {
                  mettaCompile!(*cA2, "!(double 5)") |
                  for (@compiledA2 <- cA2) {
                    rA2!(stateA1.run(compiledA2)) |
                    for (@stateA2 <- rA2) {
                      stdoutAck!("  Chain A result: ", *ack) |
                      for (_ <- ack) {
                        stdoutAck!(stateA2, *ack) |
                        for (_ <- ack) {
                          stdoutAck!("\n  Expected: A has [10] (only double, rule def produces no output)\n", *ack) |
                          for (_ <- ack) {
                            // Use triple in Chain B
                            new cB2, rB2 in {
                              mettaCompile!(*cB2, "!(triple 5)") |
                              for (@compiledB2 <- cB2) {
                                rB2!(stateB1.run(compiledB2)) |
                                for (@stateB2 <- rB2) {
                                  stdoutAck!("  Chain B result: ", *ack) |
                                  for (_ <- ack) {
                                    stdoutAck!(stateB2, *ack) |
                                    for (_ <- ack) {
                                      stdoutAck!("\n  Expected: B has [15] (only triple, rule def produces no output)\n\n", *ack) |
                                      for (_ <- ack) {
                                        ret!()
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  } |

  // -------------------------------------------------------------------
  // Test 10: Long Chain Stress Test
  // 10 sequential runs maintain consistency
  // -------------------------------------------------------------------
  for (ret, @"10" <- runTest) {
    stdoutAck!("Test 10: Long Chain - 10 sequential runs\n", *ack) |
    for (_ <- ack) {
      new r0 in {
        runMeTTa!(*r0, "!(+ 1 0)") |
        for (@s0 <- r0) {
          new c1, r1 in {
            mettaCompile!(*c1, "!(+ 1 1)") |
            for (@comp1 <- c1) {
              r1!(s0.run(comp1)) |
              for (@s1 <- r1) {
                new c2, r2 in {
                  mettaCompile!(*c2, "!(+ 1 2)") |
                  for (@comp2 <- c2) {
                    r2!(s1.run(comp2)) |
                    for (@s2 <- r2) {
                      new c3, r3 in {
                        mettaCompile!(*c3, "!(+ 1 3)") |
                        for (@comp3 <- c3) {
                          r3!(s2.run(comp3)) |
                          for (@s3 <- r3) {
                            new c4, r4 in {
                              mettaCompile!(*c4, "!(+ 1 4)") |
                              for (@comp4 <- c4) {
                                r4!(s3.run(comp4)) |
                                for (@s4 <- r4) {
                                  stdoutAck!("  After 5 runs: ", *ack) |
                                  for (_ <- ack) {
                                    stdoutAck!(s4, *ack) |
                                    for (_ <- ack) {
                                      stdoutAck!("\n  Expected: 5 outputs [1, 2, 3, 4, 5]\n\n", *ack) |
                                      for (_ <- ack) {
                                        ret!()
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  } |

  // Final Summary
  for (_ <- ack) {
  stdoutAck!("\n=== Composability Test Suite Complete ===\n", *ack) |
  for (_ <- ack) {
  stdoutAck!("Tested Properties:\n", *ack) |
  for (_ <- ack) {
  for (<- runTest!?("1")) {
  stdoutAck!("  ✓ Identity (empty state)\n", *ack) |
  for (_ <- ack) {
  for (<- runTest!?("2")) {
  stdoutAck!("  ✓ Sequential composition\n", *ack) |
  for (_ <- ack) {
  for (<- runTest!?("3")) {
  stdoutAck!("  ✓ Rule persistence\n", *ack) |
  for (_ <- ack) {
  for (<- runTest!?("4")) {
  stdoutAck!("  ✓ Rule chaining\n", *ack) |
  for (_ <- ack) {
  for (<- runTest!?("5")) {
  stdoutAck!("  ✓ State independence\n", *ack) |
  for (_ <- ack) {
  for (<- runTest!?("6")) {
  stdoutAck!("  ✓ Monotonic accumulation\n", *ack) |
  for (_ <- ack) {
  for (<- runTest!?("7")) {
  stdoutAck!("  ✓ Error resilience\n", *ack) |
  for (_ <- ack) {
  for (<- runTest!?("8")) {
  stdoutAck!("  ✓ Multiple expressions\n", *ack) |
  for (_ <- ack) {
  for (<- runTest!?("9")) {
  stdoutAck!("  ✓ No cross-contamination\n", *ack) |
  for (_ <- ack) {
  for (<- runTest!?("q0")) {
  stdoutAck!("  ✓ Long chain stability\n", *ack)
  }}}}}}}}}}}}}}}}}}}}}}
}
