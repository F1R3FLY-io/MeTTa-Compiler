// =====================================================================
// Quick Test: MeTTa Integration with Rholang (PathMap Par Version)
// =====================================================================
// This test verifies the MeTTa compiler service works with PathMap Par
// =====================================================================

new stdout(`rho:io:stdout`), stdoutAck(`rho:io:stdoutAck`),
    mettaCompile(`rho:metta:compile`),
    ack in {

  stdoutAck!("=== Testing MeTTa Integration (PathMap Par) ===\n", *ack) |

  // Test 1: Basic compilation using !? operator
  for (_ <- ack) {
    stdoutAck!("Test 1: Basic arithmetic (+ 1 2)...\n", *ack) |
    for (_ <- ack) {
      for (@statePar <- mettaCompile!?("(+ 1 2)")) {
        stdoutAck!("  Compiled state: ", *ack) |
        for (_ <- ack) {
          stdoutAck!(statePar, *ack) |
          for (_ <- ack) {
            stdoutAck!("\n", *ack)
          }
        }
      }
    }
  } |

  // Test 2: Rule definition using !? operator
  for (_ <- ack) {
    stdoutAck!("Test 2: Rule definition with !?...\n", *ack) |
    for (_ <- ack) {
      for (@statePar <- mettaCompile!?("(= (double $x) (* $x 2))")) {
        stdoutAck!("  Compiled state: ", *ack) |
        for (_ <- ack) {
          stdoutAck!(statePar, *ack) |
          for (_ <- ack) {
            stdoutAck!("\n", *ack)
          }
        }
      }
    }
  } |

  // Test 3: Error handling
  for (_ <- ack) {
    stdoutAck!("Test 3: Syntax error (unclosed paren)...\n", *ack) |
    for (_ <- ack) {
      for (@errorPar <- mettaCompile!?("(+ 1 2")) {
        stdoutAck!("  Error: ", *ack) |
        for (_ <- ack) {
          stdoutAck!(errorPar, *ack) |
          for (_ <- ack) {
            stdoutAck!("\n", *ack)
          }
        }
      }
    }
  } |

  // Test 4: Full REPL workflow using .run() method
  for (_ <- ack) {
    stdoutAck!("Test 4: REPL workflow (compile -> run -> accumulate)...\n", *ack) |
    for (_ <- ack) {
      new result1, result2 in {
        // Step 1: Compile arithmetic expression using !? operator
        for (@compiled <- mettaCompile!?("(+ 10 5)")) {
          stdoutAck!("  Step 1: Compiled (+ 10 5)\n", *ack) |
          for (_ <- ack) {
            // Step 2: Run against empty state using .run() method
            result1!({||}.run(compiled)) |
            for (@accumulatedState1 <- result1) {
              stdoutAck!("  Step 2: Evaluated - result in accumulated state\n", *ack) |
              for (_ <- ack) {
                // Step 3: Compile another expression using !? operator
                for (@compiled2 <- mettaCompile!?("(* 3 4)")) {
                  stdoutAck!("  Step 3: Compiled (* 3 4)\n", *ack) |
                  for (_ <- ack) {
                    // Step 4: Run against accumulated state using .run() method
                    result2!(accumulatedState1.run(compiled2)) |
                    for (@accumulatedState2 <- result2) {
                      stdoutAck!("  Step 4: Evaluated - both results in accumulated state\n", *ack) |
                      for (_ <- ack) {
                        stdoutAck!("\n=== All tests complete! ===\n", *ack)
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}
