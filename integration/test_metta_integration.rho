// =====================================================================
// Quick Test: MeTTa Integration with Rholang (PathMap Par Version)
// =====================================================================
// This test verifies the MeTTa compiler service works with PathMap Par
// =====================================================================

new stdout(`rho:io:stdout`), stdoutAck(`rho:io:stdoutAck`),
    mettaCompile(`rho:metta:compile`),
    mettaCompileSync(`rho:metta:compile:sync`),
    ack in {

  stdoutAck!("=== Testing MeTTa Integration (PathMap Par) ===\n", *ack) |

  // Test 1: Basic compilation with explicit return channel
  for (_ <- ack) {
    stdoutAck!("Test 1: Basic arithmetic (+ 1 2)...\n", *ack) |
    for (_ <- ack) {
      new result in {
        mettaCompile!("(+ 1 2)", *result) |
        for (@statePar <- result) {
          stdoutAck!("  Compiled state: ", *ack) |
          for (_ <- ack) {
            stdoutAck!(statePar, *ack) |
            for (_ <- ack) {
              stdoutAck!("\n", *ack)
            }
          }
        }
      }
    }
  } |

  // Test 2: Synchronous pattern compilation
  for (_ <- ack) {
    stdoutAck!("Test 2: Rule definition with sync...\n", *ack) |
    for (_ <- ack) {
      new result in {
        mettaCompileSync!("(= (double $x) (* $x 2))", *result) |
        for (@statePar <- result) {
          stdoutAck!("  Compiled state: ", *ack) |
          for (_ <- ack) {
            stdoutAck!(statePar, *ack) |
            for (_ <- ack) {
              stdoutAck!("\n", *ack)
            }
          }
        }
      }
    }
  } |

  // Test 3: Error handling
  for (_ <- ack) {
    stdoutAck!("Test 3: Syntax error (unclosed paren)...\n", *ack) |
    for (_ <- ack) {
      new result in {
        mettaCompile!("(+ 1 2", *result) |
        for (@errorPar <- result) {
          stdoutAck!("  Error: ", *ack) |
          for (_ <- ack) {
            stdoutAck!(errorPar, *ack) |
            for (_ <- ack) {
              stdoutAck!("\n", *ack)
            }
          }
        }
      }
    }
  } |

  // Test 4: Full REPL workflow using .run() method
  for (_ <- ack) {
    stdoutAck!("Test 4: REPL workflow (compile -> run -> accumulate)...\n", *ack) |
    for (_ <- ack) {
      new compiledState, result1, result2 in {
        // Step 1: Compile arithmetic expression
        mettaCompile!("(+ 10 5)", *compiledState) |
        for (@compiled <- compiledState) {
          stdoutAck!("  Step 1: Compiled (+ 10 5)\n", *ack) |
          for (_ <- ack) {
            // Step 2: Run against empty state using .run() method
            result1!({||}.run(compiled)) |
            for (@accumulatedState1 <- result1) {
              stdoutAck!("  Step 2: Evaluated - result in accumulated state\n", *ack) |
              for (_ <- ack) {
                // Step 3: Compile another expression
                new compiledState2 in {
                  mettaCompile!("(* 3 4)", *compiledState2) |
                  for (@compiled2 <- compiledState2) {
                    stdoutAck!("  Step 3: Compiled (* 3 4)\n", *ack) |
                    for (_ <- ack) {
                      // Step 4: Run against accumulated state using .run() method
                      result2!(accumulatedState1.run(compiled2)) |
                      for (@accumulatedState2 <- result2) {
                        stdoutAck!("  Step 4: Evaluated - both results in accumulated state\n", *ack) |
                        for (_ <- ack) {
                          stdoutAck!("\n=== All tests complete! ===\n", *ack)
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}
