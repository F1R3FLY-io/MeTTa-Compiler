// Test PathMap state accumulation using .run() method
new stdoutAck(`rho:io:stdoutAck`),
    mettaCompile(`rho:metta:compile`),
    testPathMapState,
    ack in {

    contract testPathMapState(return) = {
        stdoutAck!("=== Test 1: Define rule ===\n", *ack) |

        // Step 1: Compile rule definition using !? operator
        for (@compiledState1 <- mettaCompile!?("(= (double $x) (* $x 2))")) {
                stdoutAck!("  Compiled rule definition\n", *ack) |

                // Step 2: Run against empty accumulated state using .run() method
                for (_ <- ack) {
                    new result1 in {
                        result1!({||}.run(compiledState1)) |
                        for (@accumulatedState1 <- result1) {
                            stdoutAck!("  After rule definition (accumulated state)\n", *ack) |

                            // Step 3: Compile usage of rule using !? operator
                            for (_ <- ack) {
                                for (@compiledState2 <- mettaCompile!?("!(double 21)")) {
                                        stdoutAck!("=== Test 2: Use the rule ===\n", *ack) |

                                        // Step 4: Run against accumulated state using .run() method
                                        for (_ <- ack) {
                                            new result2 in {
                                                result2!(accumulatedState1.run(compiledState2)) |
                                                for (@accumulatedState2 <- result2) {
                                                    stdoutAck!("  After using rule: !(double 21) -> 42\n", *ack) |

                                                    // Step 5: Compile more computation using !? operator
                                                    for (_ <- ack) {
                                                        for (@compiledState3 <- mettaCompile!?("(+ 10 11)")) {
                                                                stdoutAck!("=== Test 3: Additional computation ===\n", *ack) |

                                                                // Step 6: Run against accumulated state
                                                                for (_ <- ack) {
                                                                    new result3 in {
                                                                        result3!(accumulatedState2.run(compiledState3)) |
                                                                        for (@finalState <- result3) {
                                                                            stdoutAck!("  Final state with all results\n", *ack) |
                                                                            for (_ <- ack) {
                                                                                return!(finalState)
                                                                            }
                                                                        }
                                                                    }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    } |

    // Run the test
    new result in {
        testPathMapState!(*result) |
        for (@finalState <- result) {
            stdoutAck!("=== Test Complete ===\n", *ack) |
            for (_ <- ack) {
                stdoutAck!("Final accumulated state: ", *ack) |
                for (_ <- ack) {
                    stdoutAck!(finalState, *ack) |
                    for (_ <- ack) {
                        stdoutAck!("\n", *ack)
                    }
                }
            }
        }
    }
}
